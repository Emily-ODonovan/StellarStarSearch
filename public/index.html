<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Stellar Star Search</title>
    <!-- <script defer src="imageProcessing.js"></script> -->
    <link rel="stylesheet" href="style.css">
    <script src="https://www.gstatic.com/firebasejs/8.2.2/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-functions.js"></script>

</head>

<body>

    <h1>Upload your image!</h1>
    <form onsubmit="loadFromForm()" id="input">
        <p for="brightness">I'm the brightness detection slider! If not enough or too many stars show up adjust me!</p>
        <label for="brightness" id="brightIndicator">Brightness Sensitivity: 75</label>
        <input type="range" id="brightness" name="If not enough or too many stars show up adjust me!" default-value="75"
            min="50" max="150">
        <input type="file" id="imgUpload" accept="image/jpeg, image/png, image/jpg">
        <input type="submit" value="Convert Image to Constallation!">
    </form>
    <p id="test"></p>
    <div id="previewDiv">
        <img id="out" class="previewImg">
        <canvas id="previewCanvas" class="preview" width="200" height="100"></canvas>
    </div>
    <form onsubmit="queryDB()" id="query">
        <input type="submit" value="Query The Database!">
    </form>

    <div id="resultDiv">
        <h1 id="starName"></h1>
        <p id="starInfo"></p>
    </div>

    <div id='aladin-lite-div' style='width: 500px; height: 500px;'></div>
    <script src='https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js' charset='utf-8'></script>

    <script type="text/javascript">
        let aladin;
        A.init.then(() => {
            aladin = A.aladin('#aladin-lite-div', { target: 'M 45', fov: 5, cooFrame: 'galactic' });

            aladin.addCatalog(A.catalogFromVizieR('V/50', 'M 45', 5, { onClick: 'showTable' }));
        });

        //on Query response
        //aladin.gotoRaDec(<ra-in-degrees>, <dec-in-degrees>);

        var form = document.getElementById("input");
        function handleForm(event) { event.preventDefault(); }
        form.addEventListener('submit', handleForm);
        const indicataor = document.getElementById("brightIndicator");

        var slider = document.getElementById("brightness");
        slider.addEventListener("change", (event) => {
            indicataor.innerHTML = "Brightness Sensitivity: " + slider.value;
        });

        const firebaseConfig = {
            apiKey: "AIzaSyBnEKJM1ojmIS2ww0xgGinn4iGcUOx2AOE",
            authDomain: "stellarstarsearch.firebaseapp.com",
            databaseURL: "127.0.0.1:8080",
            projectId: "stellarstarsearch",
            storageBucket: "stellarstarsearch.appspot.com",
            messagingSenderId: "112388706321",
            appId: "1:112388706321:web:3f91a7ff7d264d043aa1b0",
            measurementId: "G-SJ3C52P533"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const functions = firebase.functions();

        let target;
        const brightPoints = [];
        const starDistance = 15;

        async function loadFromForm() {
            document.getElementById("resultDiv").style.display = "block";

            const previewCanvas = document.getElementById("previewCanvas");
            const fileIn = document.getElementById("imgUpload");
            const imgOut = document.getElementById("out");

            brightPoints.length = 0;

            target = fileIn.files[0];

            imgOut.src = URL.createObjectURL(target);
            imgOut.onload = function () {
                findBrightPoints(imgOut, starDistance, previewCanvas, this.naturalWidth, this.naturalHeight);
                console.log(JSON.stringify(brightPoints, null, "  "));

                mutateBrightPoints(starDistance);

                let dimensions = [imgOut.width, imgOut.height];
                drawConstallation(previewCanvas, dimensions, brightPoints, starDistance);

                addCircleHoverListener(previewCanvas);
                previewCanvas.addEventListener('click', (event) => {
                    trimFalsePositives(event, previewCanvas);
                });
                //await response from firebase
                //updateBrightPoints(response);

            };
        }
        async function queryDB() {
            //query firebase for the stars
            //await response from firebase
            //updateBrightPoints(response);
        }

        //written with the help of chatGPT
        async function findBrightPoints(image, minDistance, previewCanvas, width, height) {

            // get the canvas context
            previewCanvas.width = width;
            previewCanvas.height = height;
            const ctx = previewCanvas.getContext('2d');

            // draw the image onto the canvas
            ctx.drawImage(image, 0, 0, width, height);

            // get the image data from the canvas
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const givenBrightness = document.getElementById("brightness").value;

            // loop through each pixel in the image
            for (let i = 0; i < data.length; i += 4) {
                // get the brightness of the pixel
                const brightness = (0.2126 * data[i]) + (0.7152 * data[i + 1]) + (0.073 * data[i + 2]);
                //these are the RGB brightness weighting given to each values. They were provided from chatGPT and are based on how sensitive the human eye is to each color
                //the blue value had to be modified to 0.073 from 0.0722 as in testing it was found that the blue value was too low and was not picking up enough stars alpha is ignored

                // if the pixel is bright, add it to the array
                if (brightness > givenBrightness) {
                    const x = (i / 4) % width;
                    const y = Math.floor((i / 4) / width);

                    // check if the pixel is near any existing bright points using the main array
                    let skip = false;
                    for (const point of brightPoints) {
                        const dx = x - point.x;
                        const dy = y - point.y;
                        if (Math.sqrt(dx * dx + dy * dy) < minDistance) {
                            skip = true;
                            break;
                        }
                    }

                    // if the pixel is not near any other bright points, add it to the array
                    if (!skip) {
                        brightPoints.push({ x, y });
                    }
                }
            }
        }

        function drawConstallation(previewCanvas, dimensions, points, radius) {
            const ctx = previewCanvas.getContext("2d");

            // Set the canvas dimensions
            previewCanvas.width = dimensions[0];
            previewCanvas.height = dimensions[1];

            //background first
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, dimensions[0], dimensions[1]);

            ctx.lineWidth = 2;
            ctx.strokeStyle = '#AAA';
            const maxLineDistanceInPx = 500;

            // A nested loop function that loops per point for every other point and draws a line between them if they are close enough
            for (let i = 0; i < points.length; i++) {
                const start = points[i];
                for (let j = i + 1; j < points.length; j++) {
                    if (!(i === j)) {
                        const end = points[j];

                        // Calculate the distance between the two points
                        const distance = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);

                        // Only draw the line if the distance is within the maximum distance
                        if (distance <= maxLineDistanceInPx) {
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.lineTo(end.x, end.y);
                            ctx.stroke();
                        }
                    }
                }

                // Set the fill style to white
                ctx.fillStyle = '#fff';

                // Loop through each point and draw a circle
                for (const point of points) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        //tool tips for the stars!
        function addCircleHoverListener(canvas) {
            const starName = document.getElementById('starName');
            const starInfo = document.getElementById('starInfo');
            canvas.addEventListener('mousemove', (event) => {

                const rect = canvas.getBoundingClientRect();
                const dx = event.clientX - rect.left;
                const dy = event.clientY - rect.top;

                for (const dot of brightPoints) {

                    if ((dx - dot.x) * (dx - dot.x) + (dy - dot.y) * (dy - dot.y) < dot.rXr) {
                        starName.innerHTML = dot.name;
                        // starInfo.innerHTML = dot.info;
                        //query SIMBAD from here

                        return;
                    }
                }
            });
        }

        function trimFalsePositives(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            const dx = event.clientX - rect.left;
            const dy = event.clientY - rect.top;
            for (const dot of brightPoints) {

                if ((dx - dot.x) * (dx - dot.x) + (dy - dot.y) * (dy - dot.y) < dot.rXr) {
                    const index = brightPoints.indexOf(dot);
                    if (index > -1) {
                        brightPoints.splice(index, 1);
                        drawConstallation(canvas, [canvas.width, canvas.height], brightPoints, starDistance)
                    }
                    return;
                }
            }

        }

        //mutates the bright points array to include the star distance squared and name
        function mutateBrightPoints(starDistance) {
            brightPoints.forEach(point => {
                point.x = point.x;
                point.y = point.y;
                point.rXr = starDistance * starDistance;
                point.info = "N/A";
                point.name = "Star";
                point.exclude = false;
            });
        }

        function parseBrightPoints(jsonQuery) {
            brightPoints = [];
            jsonQuery.forEach(point => {
                brightPoints.push({ x: point.x, y: point.y, rXr: point.rXr, info: point.info, name: point.name, exclude: point.exclude });
            });
        }

    </script>
</body>

</html>